zparseopts -D -E -A opts \
  f=FORCE -force=FORCE \
  h=HELP -help=HELP \
  n:=NAME -name:=NAME \
  q=QUIET -quiet=QUIET \
  v=VERBOSE -verbose=VERBOSE \
  -clean-up=CLEANUP \
  -dry-run=DRY_RUN \
  -unreachable=UNREACHABLE


# TODO: Alternatively XDG might not be set, so default to user path, .venvs dir
# TODO: If neither does exist, create dir


local CMD=${1:-""}
[[ -n ${HELP} ]] && {venv-${CMD}-help; return 0}

[[ ${#@} -gt 0 ]] && shift
local BASE_ARGS=(${@})


local GIT_DIR=$(git rev-parse --show-toplevel 2> /dev/null)
if [[ -n ${GIT_DIR} ]]; then
  local FULL_VENV=${GIT_DIR}
else
  local FULL_VENV=${PWD}
fi
local VENV=$(echo ${FULL_VENV##*/} | sed 's/ /_/')
local ALL_VENVS=${XDG_DATA_HOME}/venvs
local VENV_PATH=${ALL_VENVS}/${VENV}
local PATHS_CFG_FILE=${VENV_PATH}/.venv_paths
local IS_IN_VENV_PATHS=$(grep ${FULL_VENV} ${PATHS_CFG_FILE} 2> /dev/null)
local PYTHON3_PATH=/Library/Frameworks/Python.framework/Versions/Current/bin/python3


function __append() {
  if [[ -d ${VENV_PATH} ]]; then
    if [[ -f ${PATHS_CFG_FILE} && -n ${IS_IN_VENV_PATHS} ]]; then
      echo "'${FULL_VENV}' is already assigned to '${VENV}' venv."
      return 2
    else
      echo ${FULL_VENV} >> ${PATHS_CFG_FILE}
      return 0
    fi
  fi

  if [[ -z ${QUIET} ]]; then
    echo "Could not append '${FULL_VENV}' to '${PATHS_CFG_FILE}'"
    echo "'${VENV_PATH}' directory does not exist."
    echo
  fi

  return 2
}


function venv-activate() {
  if [[ -z ${NAME} && -d ${VENV_PATH} && -n $(grep ${FULL_VENV} ${PATHS_CFG_FILE} 2> /dev/null) ]]; then
    source ${VENV_PATH}/bin/activate
    return 0
  elif [[ -n ${NAME} ]]; then
    if [[ -d ${ALL_VENVS}/${NAME[2]} ]]; then
      source ${ALL_VENVS}/${NAME[2]}/bin/activate
      return 0
    else
      echo "Venv '${ALL_VENVS}/${NAME[2]}' does not exist."
      return 2
    fi
  fi

  if [[ -z ${QUIET} ]]; then
    echo "Your project '${FULL_VENV}' does not have related venv."
    echo
  fi

  return 2
}


function venv-auto() {
  QUIET="TRUE"

  if [[ -n ${VIRTUAL_ENV} && -n ${IS_IN_VENV_PATHS} ]]; then
    if [[ ${VIRTUAL_ENV} = ${VENV_PATH} ]]; then
      return 0
    else
      deactivate
    fi
  elif [[ -n ${VIRTUAL_ENV} && -z ${IS_IN_VENV_PATHS} ]]; then
    deactivate
  fi

  venv-activate
  return 0
}


function venv-clean() {
  local VENV_DIRECTORIES=($(\ls -1d ${ALL_VENVS}/*))

  for venv_directory in ${VENV_DIRECTORIES}; do
    local cfg_file=${venv_directory}/.venv_paths
    if [[ -f ${cfg_file} ]]; then
      while IFS= read -r project; do
        [[ ! -d ${project} ]] && echo "$(grep -v ${project} ${cfg_file})" > ${cfg_file}
      done < ${cfg_file}
    fi
  done
}


function venv-delete() {
  if [[ ${#BASE_ARGS} -eq 0 ]]; then
    if hash fzf &> /dev/null; then
      local VENVS_FOR_DELETION=($(\ls -1d ${ALL_VENVS} | fzf -m))
    else
      echo "You must provide valid directory names."
      echo "Hint: Installing 'fzf' will prevent such message in the future."
      return 1
    fi
  else
    local VENVS_FOR_DELETION=${BASE_ARGS}
  fi

  [[ ${#VENVS_FOR_DELETION} -eq 0 ]] && return 130

  # TODO: If venv is assigned to multiple, require --force otherwise --clean-up
  # TODO: If --clean-up does not contain names, then search for ureachable paths and delete them

  for venv_for_deletion in ${VENVS_FOR_DELETION}; do
    if [[ -z ${FORCE} ]]; then
      echo -n "Do you want to delete '${venv_for_deletion}'? This cannot be undone [Y/n]: "
      read ANSWER

      case ${ANSWER} in
        [yY]|"") unset ANSWER;;
        *) unset ANSWER; continue;;
      esac
    fi

    [[ ${VIRTUAL_ENV} = ${venv_for_deletion} ]] && deactivate
    rm -rf ${ALL_VENVS}/${venv_for_deletion}
    echo "Deleted: '${ALL_VENVS}/${venv_for_deletion}'"
  done

  return 0
}


function venv-list() {
  local VENV_DIRECTORIES=($(\ls -1d ${ALL_VENVS}/*))

  if [[ -n ${UNREACHABLE} ]]; then
    echo "Unreachable directories:"
    for venv_directory in ${VENV_DIRECTORIES}; do
      if [[ -f ${venv_directory}/.venv_paths ]]; then
        while IFS= read -r project; do
          [[ ! -d ${project} ]] && echo "${project} <-- ${venv_directory##*/}"
        done < ${venv_directory}/.venv_paths
      fi
    done
  else
    for venv_directory in ${VENV_DIRECTORIES}; do
      if [[ -n ${VERBOSE} && -f ${venv_directory}/.venv_paths ]]; then
        while IFS= read -r project; do
          [[ -d ${project} ]] && local existence="" || local existence=" (UNREACHABLE)"
          echo "${venv_directory##*/} --> ${project}${existence}"
        done < ${venv_directory}/.venv_paths
      else
        echo ${venv_directory##*/}
      fi
    done
  fi
}


function venv-new() {
  # TODO: Support custom venv names

  if [[ -d ${VENV_PATH} && -n ${IS_IN_VENV_PATHS} ]]; then
    echo "'${FULL_VENV}' is already assigned to '${VENV}' venv."
    return 2
  elif [[ -d ${VENV_PATH} && -z ${IS_IN_VENV_PATHS} ]]; then
    echo "Venv '${VENV}' already exists."
    echo "You can still append this project '${FULL_VENV}' to reuse the existing venv."
    echo
    echo -n "Would you like to do it [Y/n]? "
    read ANSWER

    case ${ANSWER} in
      [yY]|"") unset ANSWER;;
      *) unset ANSWER; return 0;;
    esac

    __append
    [[ $? -eq 0 ]] && venv-activate || return 2
    return $?
  fi

  ${PYTHON3_PATH} -m venv ${VENV_PATH} --system-site-packages --upgrade-deps

  if [[ -z ${QUIET} ]]; then
    echo "New venv created under:"
    echo ${VENV_PATH}
  fi

  venv-activate

  return 0
}


function venv-update() {
  if [[ ${#BASE_ARGS} -eq 0 ]]; then
    if [[ -n ${VIRTUAL_ENV} ]]; then
      local UPDATED_VENV=${VIRTUAL_ENV}
    else
      local UPDATED_VENV=${PYTHON3_PATH}
    fi
  else
    local UPDATED_VENV_PATH=${ALL_VENVS}/${BASE_ARGS[1]}
    if [[ ! -d ${UPDATED_VENV_PATH} ]]; then
      echo "No such directory: '${UPDATED_VENV_PATH}'"
      return 1
    fi
    local UPDATED_VENV=${UPDATED_VENV_PATH}/bin/python3
  fi

  local OUTDATED_PKGS=($(${UPDATED_VENV} -m pip list --outdated --format freeze | sed 's/==.*//'))

  if [[ -n ${DRY_RUN} ]]; then
    if [[ ${#OUTDATED_PKGS} -eq 0 ]]; then
      echo "All up to date!"
    else
      echo "Would update:"
      for PKG in ${OUTDATED_PKGS}; do echo "  ${PKG}"; done
    fi
    return 0
  else
    for PKG in ${OUTDATED_PKGS}; do
      if [[ -z ${QUIET} ]]; then
        ${UPDATED_VENV} -m pip install -U ${PKG}
      else
        ${UPDATED_VENV} -m pip install -qU ${PKG}
      fi
    done
  fi
}


function main() {
  case ${CMD} in
    "") venv-activate; return $?;;
    auto) venv-auto; return 0;;
    activate|clean|delete|new|update|list) venv-${CMD}; return $?;;
    *) venv--help; return 1;;
  esac
}


main
return $?

# vim:ft=zsh
